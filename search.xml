<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>前端的焦虑，你想过30岁以后的前端路怎么走吗？</title>
      <link href="/2022/12/09/%E5%89%8D%E7%AB%AF%E7%9A%84%E7%84%A6%E8%99%91/"/>
      <url>/2022/12/09/%E5%89%8D%E7%AB%AF%E7%9A%84%E7%84%A6%E8%99%91/</url>
      
        <content type="html"><![CDATA[<p>转载一位技术前辈在 30 岁时所写的</p><div class="tag link"><a class="link-card" title="前端的焦虑，你想过30岁以后的前端路怎么走吗？" href="https://juejin.cn/post/6844903615681806344"><div class="left"><img src="https://p3-passport.byteimg.com/img/user-avatar/47cf3a9648246d8df4e804ab31f66720~100x100.awebp"></div><div class="right"><p class="text">前端的焦虑，你想过30岁以后的前端路怎么走吗？</p><p class="url">https://juejin.cn/post/6844903615681806344</p></div></a></div><p>作者是我非常敬佩的一位技术前辈，这篇文章是他在 30 岁时候写下的，那时候是 2018 年。并把原文转载于此，帮助更多的童鞋能提前 5 年，提前 10 年，看到自己的职业可能性，更提前的预判到自己可能遇到的问题，并为此提前做准备，笨鸟早飞，用时间差打出自己的职业竞争力。</p><h1 id="前端的焦虑，你想过30岁以后的前端路怎么走吗？"><a href="#前端的焦虑，你想过30岁以后的前端路怎么走吗？" class="headerlink" title="前端的焦虑，你想过30岁以后的前端路怎么走吗？"></a>前端的焦虑，你想过30岁以后的前端路怎么走吗？</h1><h2 id="原因何在"><a href="#原因何在" class="headerlink" title="原因何在"></a>原因何在</h2><p>1.从客观原因来看，前端相对于后端的入门门槛确实低了不少。公司对前端的需求量虽然很旺盛，但是对前端的技术能力要求却不是很高，特别是一些小公司或者不是技术驱动的公司。这给人一种错觉，好像只需要懂一些js，会一般的html+css就能完成前端的工作。也由于这种原因，前端总是处于技术鄙视链的最底层。<br> 2.从主观原因来说，前端平时基本都是和页面和看得到的UI打交道居多，对于后端的服务，数据存储，运维，部署等等懂得的不多，也导致了领导我们的往往都是后端。在大多数的情况下，你基本很难看到前端去统筹大局，统领前后端。<br> 3.从个人原因来总结，前端经验上去了，工作年限上去了，但是职级却没有上去。归根结底，主要是因为自己的后端知识薄弱，前端深度不够。还有前端管理的职位僧多粥少导致的。</p><p>居于上述的原因，前端的天花板来得比别的技术栈更早。这也是导致我们焦虑的主要原因。既然有原因，那就可以找相应的解决方法。</p><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>1.对症下药，哪里缺乏补哪里。前端的进阶，总离不开对后端的认知。我们不能把自己限死在前端这个范畴里面。业务驱动技术，而不是技术引导业务。不懂数据库，补数据库。不懂服务端，补服务端。幸好现在有nodeJs这个利器。 我们完全可以借用nodejs，去切入后端的世界，了解和学习后端的知识。做到不受语言的限制，学习应用，也就能突破自己的瓶颈。  除了node，php也是一个不错的选择。<br> 2.主动创造条件。很多时候，选择比努力更重要。如果你发现你在一个地方再怎么努力也改变不了现状，这个时候你就应该出去别的地方看看，或者想想怎样改变现状。如果你无法升管理，那你可以尝试去别的地方当管理；如果你总是厌倦天天的无止境的切图和coding，但是又有很多想法，转岗去尝试当产品也是一个选择。<br> 3.大前端和全栈是以后前端的一个趋势，懂后端的前端，懂各端的前端更加具有竞争力，以后可以往这个方向靠拢。</p><p>现在脑补一下前端知识体系的脑图。</p><p><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090436582.webp" alt></p><p>脑图url<a href="https://link.juejin.cn?target=https%3A%2F%2Fsfault-image.b0.upaiyun.com%2F234%2F326%2F2343266726-5a01a319826bf">：https://sfault-image.b0.upaiyun.com/234/326/2343266726-5a01a319826bf</a><br> 注：脑图来自 <a href="https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000011899698">segmentfault.com/a/119000001…</a></p><p>接下来再总结一下前端以后的路怎么走。  （下面的路是我以前总结的，在csdn可以搜到）</p><h2 id="选择一：前端——高级前端——全栈——前端架构师-前端专家"><a href="#选择一：前端——高级前端——全栈——前端架构师-前端专家" class="headerlink" title="选择一：前端——高级前端——全栈——前端架构师(前端专家)"></a>选择一：前端——高级前端——全栈——前端架构师(前端专家)</h2><p>选择这条路的童鞋，最好就是技术迷，热爱前端，对技术有说不出的热情。喜欢专研，不管现在，还是将来，都乐于接受新事物新知识。</p><p>这条路的优点：一直都能呆在自己喜欢的领域，踏踏实实的敲代码，薪水也能不断提高。</p><p>这条路的缺点：30多岁还要各种敲代码，难免要被其他人管着，疲于各种公司的需求。</p><h2 id="选择二：前端——高级前端——前端主管——前端经理"><a href="#选择二：前端——高级前端——前端主管——前端经理" class="headerlink" title="选择二：前端——高级前端——前端主管——前端经理"></a>选择二：前端——高级前端——前端主管——前端经理</h2><p>这条路，可能是大部分前端，都渴望走的路，都会理所当然的以为自己以后会走上的路。这个时候问题来了？哪里来这么多的前端主管和前端经理给你啊？</p><p>这条路的优点：一步一脚印，人生不断往上爬。成为高富帅，赢取白富美，登上事业的高峰。</p><p>这条路的缺点：就拿广州来说，不要说前端经理，就是前端主管这个职位，估计也没有多少公司是存在的。很多人上到前端经理也算到顶了。这里是想说明一点，路是有的，但是选择很少。万一有一天你要跳槽了，你真的不一定能找到下一间公司，又能当会前端主管的。  我所在的公司，当得上主管或者组长这个职位的人，真的两只手就可以数完。</p><p>ps：本人其实也想走这条路，但是我很唠叨的再强调一遍，30几岁之后，你未必能找到喜欢的公司的这个职位。僧多粥少啊。最后的结果会沦为，继续当码农。</p><h2 id="选择三：前端——高级前端——转后台——高级后台——后台经理"><a href="#选择三：前端——高级前端——转后台——高级后台——后台经理" class="headerlink" title="选择三：前端——高级前端——转后台——高级后台——后台经理"></a>选择三：前端——高级前端——转后台——高级后台——后台经理</h2><p>这也是不少有实力的前端走的一条路。毕竟，在大多的公司，在大多的时候，都是后台统领着前台。说一句不好听的话，前端是一个习惯被领导的职位。 后台引导统筹项目的开发，估计大家都看得多了。前端统领后台，统筹项目开发你听过没有（除了张云龙）？ 很少。至少我是没接触过的。</p><p>这条路的优点：华丽转岗，前后通杀，也能走出一辈子码农的死循环，当上经理，做管理层。</p><p>这条路的缺点：前端转后台，这明显不是一条好走的路，需要熬很多苦，学很多后台的东西，再慢慢成长起来。简单概括就是成本高，前期很辛苦。熬过了，上路了，就有机会走上更高的台阶；熬不过了，浪费了青春，继续当个二流的后台开发，继续码农。</p><h2 id="选择四：前端——高级前端——转产品——产品经理——高级产品经理"><a href="#选择四：前端——高级前端——转产品——产品经理——高级产品经理" class="headerlink" title="选择四：前端——高级前端——转产品——产品经理——高级产品经理"></a>选择四：前端——高级前端——转产品——产品经理——高级产品经理</h2><p>这条路本人觉得也是一条不错的出路。在这个最好又最坏的年代，人人都是产品经理。在前端界打滚了这么多年，自然有不少产品的基础和思想。所以前端转产品，也是一条相对不会很吃力的路。</p><p>这条路的优点：有一定的基础，产品经理需求量大，以后的选择很多。</p><p>这条路的缺点：半路出家，前期也会很吃力地转型，转产品需要自身很有想法。懒于思考的人儿不适合。</p><h2 id="选择五：前端——高级前端——其他行业，创业等等"><a href="#选择五：前端——高级前端——其他行业，创业等等" class="headerlink" title="选择五：前端——高级前端——其他行业，创业等等"></a>选择五：前端——高级前端——其他行业，创业等等</h2><p>这条路就是现在的我，总是憧憬着以后有一份不错的生意，然后有白富美，有车有楼，财务自由的一条路。</p><p>这条路的优点：未知性很大，不用再整天敲代码，可能还真的很赚钱。</p><p>这条路的缺点：正因为未知性太大，所以前途未卜。选择走这条路的童鞋，要早早地想好要干什么，干的事情需要具备什么技能，趁早学。</p><p>总结：学无止境，祝大家都能突破自己的瓶颈。可能还有其他的路，欢迎补充。 ps：以上所说带有强烈的个人主观意愿，可能有失客观事实，望体谅。</p>]]></content>
      
      
      <categories>
          
          <category> 转载内容 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>接受自己的平凡</title>
      <link href="/2022/12/09/%E6%8E%A5%E5%8F%97%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B9%B3%E5%87%A1/"/>
      <url>/2022/12/09/%E6%8E%A5%E5%8F%97%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B9%B3%E5%87%A1/</url>
      
        <content type="html"><![CDATA[<p>其实，对于前端这份工作，我一直以来的心态就是平凡，我干的这份职业，并不值得对亲朋好友吹嘘，我干的这份工作，也仅仅是一份工作，他并不比扫大街送外卖这份职业高等好多，因为总归到头，我们都是一个大城市里的打工人。</p><p>我甚至觉得这份工作，只要正常念完中学的孩子，进培训班培训半年，也一样能做，所以我们没有资格对这份工作报以骄傲。</p><p>身边总有同事好友说：谁谁进了字节，谁谁进了腾讯，好像就能高人一等了，殊不知公司体量越大，裁员也会越多，谁都有生涯到头的时候吧。</p><p>最后，我想以一个平凡人的角度，希望正在挣扎的你能接受自己平凡</p><p>因为，很多的这样的你我，都是一样的平凡人</p><p>我们注定成不了金字塔里的顶尖</p><p>我们注定成不了行业中的翘楚</p><p>我们注定成不了传说中的扫地僧</p><p>我们注定成不了技术中的大拿</p><p>不管你究竟付出了多大的努力，也是如此。</p><p>所以，我希望这样的你，能宽恕自己的平凡，花更多的时间在陪伴家人，拓展社交，培养兴趣爱好，甚至是可以去养花花草草，有机会的话，多发展发展副业，人脉，如果能学会投资理财，这是最好的。</p><p>弱冠之年，我有这样的领悟，只是希望技术不要成为你的唯一，毕竟生活和健康，才是你真正需要拥有的东西</p><p>弱冠之年，我接受这样平凡的自己</p><p>就像许巍的歌“曾梦想仗剑走天涯，看一看世界的繁华”</p><p>这让我想起几年前的自己，刚来到南京的第一天，迎着夕阳，走在双龙大道的马路边</p><p>地上的影子被斜阳拉的老长老长，金灿灿的光照耀在人的脸上 而不觉得耀眼</p><p>彼此挥斥方遒，有说有笑，诉说着彼此都有着的那远大的目标和理想</p><p>我也曾拥有每个前端人的那个最初的梦想“努力钻研技术，出任公司ceo，赢取白富美，走上人生巅峰”</p><p>但是繁华过后，确是生活的平凡和美好</p>]]></content>
      
      
      <categories>
          
          <category> 生活随笔 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 思考 </tag>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移动Web笔记</title>
      <link href="/2022/12/09/%E7%A7%BB%E5%8A%A8Web%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/12/09/%E7%A7%BB%E5%8A%A8Web%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="移动Web"><a href="#移动Web" class="headerlink" title="移动Web"></a>移动Web</h1><h1 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h1><h4 id="rem单位"><a href="#rem单位" class="headerlink" title="rem单位"></a>rem单位</h4><p>rem:是一个相对单位，类似于em,不同的是rem的基准是相对于html元素的字体大小。</p><p>rem优点：可以通过修改html里面的文字大小来改变页面中元素的大小，可以整体控制</p><p>em：是一个相对单位，父元素的字体大小</p><h5 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h5><style>  div {    font-size: 12px;  }  p {    width: 10em;    height: 10em;  }</style><body>  <div>    <p></p>  </div></body><p>1em=12px</p><p>10em=120px</p><h2 id="媒体查询"><a href="#媒体查询" class="headerlink" title="媒体查询"></a>媒体查询</h2><p>语法:</p><p>顺序：</p><p>screen和and必须带上不能省略</p><p>px单位不能省略的</p><h4 id="媒体查询-rem实现元素动态化大小变化"><a href="#媒体查询-rem实现元素动态化大小变化" class="headerlink" title="媒体查询+rem实现元素动态化大小变化"></a>媒体查询+rem实现元素动态化大小变化</h4><p>引入资源：</p><p> 媒体查询最好的方法：从小到大</p><p>针对不同的屏幕尺寸，调用用不同的css样式文件</p><p>当样式比较繁多的时候 ,我们可以针对不同的媒体使用不同 stylesheets (样式表 )。<br>原理, 就是直接在link中判断设备的尺寸,然后引用不同的css文件。</p><h2 id="Less"><a href="#Less" class="headerlink" title="Less"></a>Less</h2><h4 id="css弊端"><a href="#css弊端" class="headerlink" title="css弊端"></a>css弊端</h4><p>CSS是一门非程序式语言,没有变量、函数、SCOPE (作用域)等概念。<br>●CSS需要书写大量看似没有逻辑的代码, CSS冗余度是比较高的。<br>●不方便维护及扩展,不利于复用。<br>●CSS没有很好的计算能力<br>●非前端开发工程师来讲,往往会因为缺少CSS编写经验而很难写出组织良好且易于维护的CSS代码项目。</p><h4 id="Less介绍"><a href="#Less介绍" class="headerlink" title="Less介绍"></a>Less介绍</h4><p>Less ( Leaner Style Sheets的缩写)是门CSS扩展语言,也成为CSS预处理器。<br>做为CSS的一种形式的扩展,它并没有减少CSS的功能,而是在现有的CSS语法上,为CSS加入程序式语言的特性。<br>它在CSS的语法基础之上,引入了变量, Mixin(混入) , 运算I以及函数等功能,大大简化了CSS的编写，并且降低了CSS的维护成本,就像它的名称所说的那样, Less可以让我们用更少的代码做更多的事情。</p><p>常见的CSS预处理器: Sass、Less、 Stylus</p><p>一句话: Less是一门CSS预处理语言,它扩展了CSS的动态特性。</p><h4 id="Less使用"><a href="#Less使用" class="headerlink" title="Less使用"></a>Less使用</h4><p>我们首先新建一 个后缀名为less的文件，在这个Iess文件里面书写less语句，编译为css,引用</p><h4 id="Less变量"><a href="#Less变量" class="headerlink" title="Less变量"></a>Less变量</h4><p>1.变量命名规范<br>●必须有@为前缀<br>●不能包含特殊字符<br>●不能以数字开头<br>●大小写敏感</p><h4 id="Less编译"><a href="#Less编译" class="headerlink" title="Less编译"></a>Less编译</h4><p>本质上, Less包含-套自定义的语法及-一个解析器,用户根据这些语法定义自己的样式规则,这些规则<br>最终会通过解析器,编译生成对应的CSS文件上，所以,我们需要把我们的less文件,编译生成为css文件,这样我们的html页面才能使用。</p><h4 id="Less嵌套"><a href="#Less嵌套" class="headerlink" title="Less嵌套"></a>Less嵌套</h4><p>less嵌套子元素的样式直接写到父元素里面就好了 </p><p>如果有伪类、交集选择器、伪元素选择器我们内层选择器的前面需要加&amp;</p><h4 id="Less运算"><a href="#Less运算" class="headerlink" title="Less运算"></a>Less运算</h4><p>任何数字、颜色或者变量都可以参与运算。就是Less提供了加(+ )、减(-)、乘(*)、除(/)算术运算</p><h5 id="注意"><a href="#注意" class="headerlink" title="注意:"></a>注意:</h5><p>●乘号(*)和除号(/)的写法，现在除法需要加括号：width：（750rem /  @num);<br>●运算符中间左右有个空格隔开1px + 5<br>●对于两个不同的单位的值之间的运算,运算结果的值取第一个值的单位<br>●如果两个值之间只有一 个值有单位 ,则运算结果就取该单位</p><h2 id="rem适配方案"><a href="#rem适配方案" class="headerlink" title="rem适配方案"></a>rem适配方案</h2><h4 id="1-我们适配的目标是什么"><a href="#1-我们适配的目标是什么" class="headerlink" title="1.我们适配的目标是什么?"></a>1.我们适配的目标是什么?</h4><p>1.让一些不能等比自适应的元素,达到当设备尺寸发生改变的时候,等比例适配当前设备。</p><h4 id="2-怎么去达到这个目标的"><a href="#2-怎么去达到这个目标的" class="headerlink" title="2.怎么去达到这个目标的?"></a>2.怎么去达到这个目标的?</h4><p>2.使用媒体查询根据不同设备按比例设置html的字体大小然后页面元素使用rem做尺寸单位,当htmI字体大小变化，元素尺寸也会发生变化,从而达到等比缩放的适配。</p><h4 id="3-在实际的开发当中使用"><a href="#3-在实际的开发当中使用" class="headerlink" title="3.在实际的开发当中使用?"></a>3.在实际的开发当中使用?</h4><p>①按照设计稿与设备宽度的比例,动态计算并设置html根标签的font-size大小; (媒体查询)<br>②CSS中,设计稿元素的宽、高、相对位置等取值,按照同等比例换算为rem为单位的值;</p><h4 id="rem适配方案技术使用-市场主流"><a href="#rem适配方案技术使用-市场主流" class="headerlink" title="rem适配方案技术使用(市场主流)"></a>rem适配方案技术使用(市场主流)</h4><p>技术方案1</p><p>●less</p><p>●媒体查询</p><p>●rem</p><p>技术方案2 (推荐)</p><p>●flexible.js</p><p>●rem </p><p>总结:<br>1.两种方案现在都存在。<br>2.方案2更简单,现阶段大家无需了解里面的js代码。</p><h5 id="rem实际开发适配方案1"><a href="#rem实际开发适配方案1" class="headerlink" title="rem实际开发适配方案1:"></a>rem实际开发适配方案1:</h5><p>rem +媒体查询+ less技术</p><p>1.设计稿常见尺寸宽度</p><div class="table-container"><table><thead><tr><th>设备</th><th>常见宽度</th></tr></thead><tbody><tr><td>iphone 4.5</td><td>640px</td></tr><tr><td>iphone 678</td><td>750px</td></tr><tr><td>Android</td><td>常见320px、360px、 375px、 384px、 400px、 414px. 500px、 720px<br>大部分4.7~5寸的安卓设备为720px</td></tr></tbody></table></div><h6 id="2-动态设置html标签font-size大小"><a href="#2-动态设置html标签font-size大小" class="headerlink" title="2.动态设置html标签font-size大小"></a>2.动态设置html标签font-size大小</h6><p>①假设设计稿是750px<br>②假设我们把整个屏幕划分为15等份(划分标准不一可以是20份也可以是10等份)<br>③每-份作为htm|字体大小,这里就是50px<br>④那么在320px设备的时候,字体大小为320/15就是21.33px<br>⑤用我们页面元素的大小除以不同的html字体大小会发现他们比例还是相同的<br>⑥比如我们以750为标准设计稿<br>⑦一个100<em>100像素的页面元素在750屏幕下，就是100/ 50转换为rem是2rem </em> 2 rem比例是1比1<br>⑧320屏幕下，html字体大小为21.33 则2rem= 42.66px此时宽和高都是42.66 但是宽和高的比例还是1比1<br>⑨但是已经能实现不同屏幕下页面元素盒子等比例缩放的效果</p><h6 id="3-元素大小取值方法"><a href="#3-元素大小取值方法" class="headerlink" title="3.元素大小取值方法"></a>3.元素大小取值方法</h6><p>①最后的公式:页面元素的rem值=页面元素值( px) / ( 屏幕宽度/划分的份数)<br>②屏幕宽度/划分的份数就是html font- size的大小<br>③或者:页面元素的rem值=页面元素值( px) / html font-size 字体大小    </p><h5 id="rem实际开发适配方案2"><a href="#rem实际开发适配方案2" class="headerlink" title="rem实际开发适配方案2:"></a>rem实际开发适配方案2:</h5><p>rem+flexible.js简洁高效</p><p>手机淘宝团队出的简洁高效移动端适配库<br>我们再也不需要在写不同屏幕的媒体查询,因为里面js做了处理,它的原理是把当前设备划分为10等份,但是不同设备下,比例还是一致的。<br>我们要做的,就是确定好我们当前设备的html字大小就可以了,比如当前设计稿是750px，那么我们只需要把html文字大小设置为75px(750px/ 10)就可以,里面页面元素rem值:页面元素的px值/ 75,剩余的让flexible.js来去算</p><h6 id="VSCode-px-转换rem插件cssrem"><a href="#VSCode-px-转换rem插件cssrem" class="headerlink" title="VSCode px 转换rem插件cssrem"></a>VSCode px 转换rem插件cssrem</h6><h1 id="响应式开发"><a href="#响应式开发" class="headerlink" title="响应式开发"></a>响应式开发</h1><h4 id="响应式开发原理"><a href="#响应式开发原理" class="headerlink" title="响应式开发原理"></a>响应式开发原理</h4><ul><li>概念：对不同屏幕尺寸做出响应，并进行相应布局</li><li>原理：使用媒体查询设置不同的断点，进行不同css布局响应</li><li>优点：一个网站可以兼容多种终端，不需要重复开发</li><li>缺点：工作量大、代码累赘、加载时间长、效率低、冗余代码较多</li><li>适用场景：结构比较简单，展示型网站</li><li>不适用场景：交互较多，功能性的网站不适用</li></ul><p>就是使用<strong>媒体查询</strong>针对不同宽度的设备进行<strong>布局和样式</strong>的设置,从而适配不同设备的目的。</p><div class="table-container"><table><thead><tr><th style="text-align:center">设备划分</th><th style="text-align:left">尺寸区间</th><th>响应式尺寸划分（一般情况）</th></tr></thead><tbody><tr><td style="text-align:center">超小屏幕(手机)</td><td style="text-align:left">&lt; 768px</td><td>100%</td></tr><tr><td style="text-align:center">小屏设备(平板)</td><td style="text-align:left">&gt;= 768px ~ &lt; 992px</td><td>750px</td></tr><tr><td style="text-align:center">中等屏幕(桌面显示器)</td><td style="text-align:left">&gt;= 992px ~ &lt; 1200px</td><td>970px</td></tr><tr><td style="text-align:center">宽屏设备(大桌面显示器)</td><td style="text-align:left">&gt;= 1200px</td><td>1170px</td></tr></tbody></table></div><h4 id="响应式布局容器"><a href="#响应式布局容器" class="headerlink" title="响应式布局容器"></a>响应式布局容器</h4><p>响应式需要一个父级做为布局容器 ,来配合子级元素来实现变化效果。<br>原理就是在不同屏幕下,通过媒体查询来改变这个布局容器的大小,再改变里面<strong>子元素的排列方式和大小</strong>,从而实现<br>不同屏幕下,看到不同的页面布局和样式变化。</p><h1 id="Bootstrap"><a href="#Bootstrap" class="headerlink" title="Bootstrap"></a>Bootstrap</h1><p>Bootstrap来自Twitter (推特) ,是目前最受欢迎的前端框架。Bootstrap 是基于HTML、CSS 和JAVASCRIPT的，它简洁灵活,使得Web开发更加快捷。</p><p><strong>框架</strong>:顾名思义就是一套架构, 它有一套比较完整的网页功能解决方案 ,而且控制权在框架本身,有预制样式库、组件和插件。使用者要按照框架所规定的某种规范进行开发。</p><p>●中文官网: <a href="http://www.bootcss.com/">http://www.bootcss.com/</a><br>●官网: <a href="http://getbootstrap.com/">http://getbootstrap.com/</a></p><h4 id="Bootstrap优点"><a href="#Bootstrap优点" class="headerlink" title="Bootstrap优点"></a>Bootstrap优点</h4><p>●标准化的html + css编码规范<br>●提供了一套简洁、直观、强悼的组件<br>●有自己的生态圈,不断的更新迭代<br>●让开发更简单,提高了开发的效率</p><h4 id="Bootstrap使用四步曲"><a href="#Bootstrap使用四步曲" class="headerlink" title="Bootstrap使用四步曲:"></a>Bootstrap使用四步曲:</h4><p>1.创建文件夹结构2.创建html骨架结构3. 引入相关样式文件4. 书写内容</p><h4 id="Bootstrap布局容器"><a href="#Bootstrap布局容器" class="headerlink" title="Bootstrap布局容器"></a>Bootstrap布局容器</h4><p>Bootstrap需要为页面内容和栅格系统包裹一个.container容器, Bootstarp<strong>预先定义</strong>好了这个类,叫.container<br>它提供了两个作此用处的类。</p><ol><li><h5 id="container类"><a href="#container类" class="headerlink" title="container类"></a><strong>container类</strong></h5><p>|        设备划分        | 尺寸区间            | 响应式尺寸划分（一般情况） |<br>| :——————————: | :————————— | ————————————— |<br>|     超小屏幕(手机)     | &lt; 768px             | 100%                       |<br>|     小屏设备(平板)     | &gt;= 768px ~ &lt; 992px  | 750px                      |<br>|  中等屏幕(桌面显示器)  | &gt;= 992px ~ &lt; 1200px | 970px                      |<br>| 宽屏设备(大桌面显示器) | &gt;= 1200px           | 1170px                     |</p></li></ol><ol><li><h5 id="container-fluid类"><a href="#container-fluid类" class="headerlink" title="container-fluid类"></a>container-fluid类</h5><p>●流式布局容器百分百宽度<br>●占据全部视口( viewport )的容器。<br>●适合于单独做移动端开发</p></li></ol><h4 id="栅格系统简介"><a href="#栅格系统简介" class="headerlink" title="栅格系统简介"></a>栅格系统简介</h4><p>栅格系统英文为”grid systems” ,也有人翻译为“网格系统”，它是指将页面布局划分为等宽的列 ,然后通过列数的定义来模块化页面布局。</p><p>Bootstrap提供了一套响应式、 移动设备优先的流式栅格系统,随着屏幕或视口( viewport )尺寸的增加，系统会自动分为最多12列。</p><p>Bootstrap里面container宽度是固定的,但是不同屏幕下, container的宽度不同,我们再把container划分为12等份</p><h4 id="栅格选项参数"><a href="#栅格选项参数" class="headerlink" title="栅格选项参数"></a>栅格选项参数</h4><p>栅格系统用于通过一系列的行 ( row )与列( column )的组合来创建页面布局,你的内容就可以放入这些创建好的布局中。</p><div class="table-container"><table><thead><tr><th style="text-align:center">设备划分</th><th style="text-align:left">尺寸区间</th><th>响应式尺寸划分（一般情况）</th><th>类前缀</th></tr></thead><tbody><tr><td style="text-align:center">超小屏幕(手机)</td><td style="text-align:left">&lt; 768px</td><td>100%</td><td>.col-xs-</td></tr><tr><td style="text-align:center">小屏设备(平板)</td><td style="text-align:left">&gt;= 768px ~ &lt; 992px</td><td>750px</td><td>.col-sm-</td></tr><tr><td style="text-align:center">中等屏幕(桌面显示器)</td><td style="text-align:left">&gt;= 992px ~ &lt; 1200px</td><td>970px</td><td>.col-md-</td></tr><tr><td style="text-align:center">宽屏设备(大桌面显示器)</td><td style="text-align:left">&gt;= 1200px</td><td>1170px</td><td>.col-lg-</td></tr></tbody></table></div><p>如果子元素的份数相加等于12，则子元素能占满整个的container的宽度</p><p>如果子元素的份数相加小于12，则占不满整个container的宽度，会有空白</p><p>如果子元素的份数相加大于12，则多于的那一列会另起一行显示</p><p>●按照不同屏幕划分为1~12等份<br>●行( row )可以法除父容器作用15px的边距</p><p>●行( row )必须放到container布局容器里面<br>●我们实现列的平均划分需要给列添加类前缀<br>●xs-extra small :超小; sm-small :小; md-medium :中等; lg-large :大;<br>●列( column)大于12 ,多余的“列( column )”所在的元素将被作为一个整体另起一行排列<br>●每一 列默认有左右15像素的padding值<br>●可以同时为一-列指定多个设备的类名,以便划分不同份数例如class=”col-md-4 col-sm-6”</p><h4 id="列嵌套"><a href="#列嵌套" class="headerlink" title="列嵌套"></a>列嵌套</h4><p>栅格系统内置的栅格系统将内容再次嵌套。简单理解就是一个列内再粉成若干份小列。我们可以通过添加一个新的.row元素和一系列.col-sm-<em>元素到已经存在的.col-sm-</em>元素内。</p><p>我们列嵌套最好加1个行row这样可以取消父元素的padding值而且高度自动和父级一样高</p><p><strong>实例：</strong></p><pre><code>  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot; col-md-4&quot;&gt;        &lt;div class=&quot;row&quot;&gt;          &lt;div class=&quot; col-md-6&quot;&gt;小列&lt;/div&gt;          &lt;div class=&quot; col-md-6&quot;&gt;小列&lt;/div&gt;        &lt;/div&gt;      &lt;/div&gt;      &lt;div class=&quot; col-md-4&quot;&gt;2&lt;/div&gt;      &lt;div class=&quot; col-md-4&quot;&gt;3&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><h4 id="列偏移"><a href="#列偏移" class="headerlink" title="列偏移"></a>列偏移</h4><p>使用.col-md-offset-number类可以将列向右侧偏移。这些类实际是通过使用*选择器为当前元素增加了左侧的边距( margin)。</p><p>实例：</p><pre><code>  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-md-6&quot;&gt;左侧&lt;/div&gt;      &lt;div class=&quot;col-md-6 col-md-offset-3&quot;&gt;右侧&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><h4 id="列排序"><a href="#列排序" class="headerlink" title="列排序"></a>列排序</h4><p>通过使用.col-md-push-number和.col-md-pull-number类就可以很容易的改变列( column )的顺序。</p><p>实例：</p><pre><code>  &lt;div class=&quot;container&quot;&gt;    &lt;div class=&quot;row&quot;&gt;      &lt;div class=&quot;col-md-4 col-md-push-8&quot;&gt;左侧&lt;/div&gt;      &lt;div class=&quot;col-md-8 col-md-pull-4&quot;&gt;右侧&lt;/div&gt;    &lt;/div&gt;  &lt;/div&gt;</code></pre><h4 id="响应式工具"><a href="#响应式工具" class="headerlink" title="响应式工具"></a>响应式工具</h4><p>为了加快对移动设备友好的页面开发工作,利用媒体查询功能,并使用这些工具类可以方便的针对不同设备<br>展示或隐藏页面内容。</p><div class="table-container"><table><thead><tr><th>类名</th><th>超小屏</th><th>小屏</th><th>中屏</th><th>大屏</th></tr></thead><tbody><tr><td>hidden-xs</td><td>隐藏</td><td>可见</td><td>可见</td><td>可见</td></tr><tr><td>.hidden-md</td><td>可见</td><td>隐藏</td><td>可见</td><td>可见</td></tr><tr><td>.hidden-lg</td><td>可见</td><td>可见</td><td>隐藏</td><td>可见</td></tr><tr><td>可见</td><td>可见</td><td>可见</td><td>可见</td><td>隐藏</td></tr></tbody></table></div><p>与之相反的,是visible-xs visible-sm visible-md visible-lg是显示某个页面内容</p><h6 id="Boorstrap清除浮动：clearfix"><a href="#Boorstrap清除浮动：clearfix" class="headerlink" title="Boorstrap清除浮动：clearfix"></a>Boorstrap清除浮动：clearfix</h6><h1 id="移动端布局总结"><a href="#移动端布局总结" class="headerlink" title="移动端布局总结"></a>移动端布局总结</h1><h3 id="移动端主流方案"><a href="#移动端主流方案" class="headerlink" title="移动端主流方案"></a>移动端主流方案</h3><h4 id="1-单独制作移动端页面-主流"><a href="#1-单独制作移动端页面-主流" class="headerlink" title="1.单独制作移动端页面(主流)"></a>1.单独制作移动端页面(主流)</h4><p>流式布局(百分比布局)</p><p>flex弹性布局(强烈推荐)</p><p>ess+rem+媒体查询布局</p><p>混合布局</p><h4 id="2-响应式页面兼容移动端-其次"><a href="#2-响应式页面兼容移动端-其次" class="headerlink" title="2.响应式页面兼容移动端(其次)"></a>2.响应式页面兼容移动端(其次)</h4><p>媒体查询</p><p>bootstarp</p><h3 id="移动端技术选型"><a href="#移动端技术选型" class="headerlink" title="移动端技术选型"></a>移动端技术选型</h3><ul><li><h5 id="流式布局-百分比布局"><a href="#流式布局-百分比布局" class="headerlink" title="流式布局(百分比布局)"></a>流式布局(百分比布局)</h5></li><li><h5 id="flex弹性布局-推荐"><a href="#flex弹性布局-推荐" class="headerlink" title="flex弹性布局(推荐)"></a>flex弹性布局(推荐)</h5></li><li><h5 id="rem适配布局-推荐"><a href="#rem适配布局-推荐" class="headerlink" title="rem适配布局(推荐)"></a>rem适配布局(推荐)</h5></li><li><h5 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h5><p>建议:我们选取一种主要技术选型,其他技术做为辅助,这种混合技术开发</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 响应式开发 </tag>
            
            <tag> Bootstrap </tag>
            
            <tag> 移动端 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call 和apply的作用与区别</title>
      <link href="/2022/12/09/call%20%E5%92%8Capply%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/"/>
      <url>/2022/12/09/call%20%E5%92%8Capply%E7%9A%84%E4%BD%9C%E7%94%A8%E4%B8%8E%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<p>首先先说明它们共同的作用：call和apply 都是用来修改函数中this的指向问题；</p><p>其次就是它们不同的传参方式：注意上一句话中说他们的作用时有两个关键词 ‘函数’和‘this’，想要修改this 的指向，那么必然有一个this修改后的指向，而函数必然后关系到传参问题：call方法可以传给该函数的参数分别作为自己的多个参数，而apply方法必须将传给该函数的参数合并成一个<a href="https://so.csdn.net/so/search?q=%E6%95%B0%E7%BB%84&amp;spm=1001.2101.3001.7020">数组</a>作为自己的一个参数：</p><p>eg: </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;Evan&#x27;</span>;<span class="hljs-keyword">var</span> age = <span class="hljs-number">20</span>;<span class="hljs-keyword">var</span> person = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Hillary&#x27;</span>,    <span class="hljs-attr">age</span>: <span class="hljs-number">19</span>,    <span class="hljs-attr">sayIntroduce</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello, My name is &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot; and I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span> + <span class="hljs-string">&#x27; years old.&#x27;</span>    &#125;,    <span class="hljs-attr">sayHobby</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params">val1, val2</span>) &#123;        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;I&#x27;m &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> + <span class="hljs-string">&quot;, I like &quot;</span> + val1 + <span class="hljs-string">&quot; and &quot;</span> + val2 + <span class="hljs-string">&quot;.&quot;</span>;    &#125;&#125;<span class="hljs-keyword">var</span> person1 = &#123;    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Coy&#x27;</span>&#125;<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-title function_">sayIntroduce</span>()); <span class="hljs-comment">// Hello, My name is Hillary and I&#x27;m 19 years old.</span><br></code></pre></td></tr></table></figure><p>当我们通过 call 和 apply 来this的指向时，不传任何参数，则默认为将this指向修改为  windows</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 当没有参数时，默认将this指向 window console.log(person.sayIntroduce.call()); // Hello, My name is Evan and I&#x27;m 20 years old. console.log(person.sayIntroduce.apply()); // Hello, My name is Evan and I&#x27;m 20 years old.</span><br></code></pre></td></tr></table></figure><p>有参数时，this 指向第一个参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 将this指向 person1，由于person1中没有age属性，因此为 undefinedconsole.log(person.sayIntroduce.call(person1)); // Hello, My name is Coy and I&#x27;m undefined years old.console.log(person.sayIntroduce.apply(person1)); // Hello, My name is Coy and I&#x27;m undefined years old.</span><br></code></pre></td></tr></table></figure><p>当需要传递参数时，call可以直接写多个参数，apply需要用数组方式传递：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">sayHobby</span>.<span class="hljs-title function_">call</span>(person1, <span class="hljs-string">&#x27;swimming&#x27;</span>, <span class="hljs-string">&#x27;hiking&#x27;</span>)); <span class="hljs-comment">// I&#x27;m Coy, I like swimming and hiking.console.log(person.sayHobby.apply(person1, [&#x27;swimming&#x27;, &#x27;hiking&#x27;])); // I&#x27;m Coy, I like swimming and hiking.</span><br></code></pre></td></tr></table></figure><p>下面是一个构造函数的例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//构造函数应用function Grade(max, min, average) &#123;    this.max = max;    this.min = min;    this.average = average;&#125; function Subject(subjectName,max, min, average) &#123;    Grade.call(this, max, min, average);    this.subjectName = subjectName;&#125;var math = new Subject(&#x27;math&#x27;, 99, 60, 80);console.log(math);</span><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>10分钟理解ES6箭头函数</title>
      <link href="/2022/12/09/10%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/"/>
      <url>/2022/12/09/10%E5%88%86%E9%92%9F%E7%90%86%E8%A7%A3ES6%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><blockquote><p>面试中，<a href="https://so.csdn.net/so/search?q=ES6&amp;spm=1001.2101.3001.7020">ES6</a> 是一大考点，当被问到箭头函数时，我们都会说：箭头函数很好用，而且再也不用操心 this 的指向了。<br>面试官：<strong>箭头函数是挺好用的，那有哪些不适合使用箭头函数的场景呢？</strong></p></blockquote><p><a href="https://so.csdn.net/so/search?q=%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&amp;spm=1001.2101.3001.7020">箭头函数</a>在大多数情况下，是很好用的，但是为什么在有些场景，使用箭头函数后会产生问题？是不是箭头函数还不够完善？又有哪些场景会发生问题？该如何解决呢？为了防止血案的产生，重新吧这一块拎出来整理巩固一下。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>ES6允许使用<code>箭头（=&gt;）定义函</code>数，箭头函数提供了一种更加简洁的函数书写方式，箭头函数<code>多用于匿名函数的定义</code>；</p></blockquote><h2 id="箭头函数的注意点："><a href="#箭头函数的注意点：" class="headerlink" title="箭头函数的注意点："></a>箭头函数的注意点：</h2><ol><li><p>如果形参只有一个，则小括号可以省略；</p></li><li><p>函数体如果只有一条语句，则花括号可以省略，并省略return，函数的返回值为该条语句的执行结果；</p></li><li><p>箭头函数 this 指向声明时所在作用域下 this 的值；</p></li><li><p>箭头函数不能作为构造函数实例化；</p></li><li><p>不能使用 arguments；</p></li></ol><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><blockquote><ol><li>箭头函数的this<code>是静态的</code>，<code>始终指向函数声明时所在作用域下的this</code>的值；</li><li>不能作为构造实例化对象；</li><li>不能使用 arguments 变量；</li></ol></blockquote><h2 id="箭头函数的写法"><a href="#箭头函数的写法" class="headerlink" title="箭头函数的写法"></a>箭头函数的写法</h2><p>为什么叫箭头函数( Arrow Function )？因为它的写法，看上去就是一个箭头：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs json">const multiply = num =&gt; num * num;<br></code></pre></td></tr></table></figure><p>它等价于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> multiply = <span class="hljs-keyword">function</span> (<span class="hljs-params">num</span>) &#123;<br>    <span class="hljs-keyword">return</span> num * num;<br>&#125;;<br></code></pre></td></tr></table></figure><p>此外，还可以传多个参数，以及可变参数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// 多参数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">multiply</span> = (<span class="hljs-params">num1, num2</span>) =&gt; num1 * num2;<br><br><span class="hljs-comment">// 可变参数</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">sum</span> = (<span class="hljs-params">num1, num2, ...rest</span>) =&gt; &#123;<br>    <span class="hljs-keyword">let</span> result = num1 + num2;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; rest.<span class="hljs-property">length</span>; i++) &#123;<br>        result += rest[i];<br>    &#125;<br>    <br>    <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure><p>当有多条语句时，需要配上 <code>&#123;...&#125;</code> 和 <code>return</code>。</p><p>另外，如果返回的结果是对象，则需要配上 <code>()</code>，像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">func</span> = val =&gt; (&#123; <span class="hljs-attr">value</span>: val &#125;);<br></code></pre></td></tr></table></figure><p>从上述的写法来看，相较普通函数而言，箭头函数的确简便了很多，提升了我们代码的易用性。但它并非在任何场景下都适用，接下来，将会介绍几种不适合箭头函数的场景，并会提出可行的解决方案。</p><h2 id="不适合的场景"><a href="#不适合的场景" class="headerlink" title="不适合的场景"></a>不适合的场景</h2><h4 id="1、对象的方法"><a href="#1、对象的方法" class="headerlink" title="1、对象的方法"></a>1、对象的方法</h4><p>看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> obj = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">print</span>: <span class="hljs-function">() =&gt;</span> &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>); <span class="hljs-comment">// =&gt; true</span><br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>); <span class="hljs-comment">// undefined</span><br>    &#125;<br>&#125;;<br><br>obj.<span class="hljs-title function_">print</span>();<br></code></pre></td></tr></table></figure><p>this.x 打印出来是 undefined。为什么？然后，我在上面加了一行，发现 this 指向了 window。</p><p>解析：print 方法用了箭头函数，其内部的 this 指向的还是上下文 window，上下文中并没有定义 x，所以 this.x 输出为 undefined。</p><p>解决办法：用 ES6 的短语法，或者传统的函数表达式都可以。所以，print 要这样写：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">print () &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === test); <span class="hljs-comment">// =&gt; true</span><br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">x</span>); <span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2、原型方法"><a href="#2、原型方法" class="headerlink" title="2、原型方法"></a>2、原型方法</h4><p>同样的规则也适用于原型方法的定义，使用箭头函数会导致运行时的执行上下文错误。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Cat</span> (name) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name;<br>&#125;<br><br><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayCatName</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>); <span class="hljs-comment">// =&gt; true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;;<br><br><span class="hljs-keyword">const</span> cat = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-string">&#x27;Miao&#x27;</span>);<br>cat.<span class="hljs-title function_">sayCatName</span>(); <span class="hljs-comment">// =&gt; undefined</span><br></code></pre></td></tr></table></figure><p>解决办法是：用回传统的函数表达式，像下面这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-title class_">Cat</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">sayCatName</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === cat); <span class="hljs-comment">// =&gt; true</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>sayCatName 变回传统的函数表达式之后，被调用时的执行上下文就会指向新创建的 cat 实例。</p><h4 id="3、事件的回调"><a href="#3、事件的回调" class="headerlink" title="3、事件的回调"></a>3、事件的回调</h4><p>看下面这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> btn = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;myButton&#x27;</span>);<br>btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === <span class="hljs-variable language_">window</span>); <span class="hljs-comment">// =&gt; true</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;Clicked button&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>这里会有问题，因为 this 指向了 window。</p><p>解析：当为一个 DOM 事件绑定回调函数后，触发回调函数时的 this，需要指向当前发生事件的 DOM 节点，也就是这里的 btn。当回调发生时，浏览器会用 btn 的上下文去调用处理函数。所以最后的 this.innerHTML 等价于 window.innerHTML，问题就在这里。</p><p>解决办法：用函数表达式代替箭头函数。像这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">btn.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === btn); <span class="hljs-comment">// =&gt; true</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&#x27;Clicked button&#x27;</span>;<br>&#125;);<br></code></pre></td></tr></table></figure><p>另外，在 react 中的事件回调，也经常会遇到类似的问题。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs html">// jsx render<br><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.handleClickButton.bind(this)&#125;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br><br>// callback<br>handleClickButton () &#123;<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这里 onClick 的回调函数，并非字符串，而是一个实实在在的函数。可以将 onClick 理解为一个中间变量，所以 react 在处理函数时的 this 指向就会丢失。</p><p>为了解决这个问题，我们需要为回调函数绑定 this，使得事件处理函数无论如何传递，this 都指向我们实例化的那个对象。</p><p>在这里，如果用箭头函数，可以这样改写：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">Button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;</span> <span class="hljs-attr">event</span> =&gt;</span> this.handleClickButton(event) &#125;&gt;<br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">Button</span>&gt;</span><br></code></pre></td></tr></table></figure><p>箭头函数并没有自己的 this，所以事件处理函数的调用者并不受影响。</p><h4 id="4、构造函数"><a href="#4、构造函数" class="headerlink" title="4、构造函数"></a>4、构造函数</h4><p>箭头函数不能通过 new 关键字调用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> <span class="hljs-title function_">Message</span> = (<span class="hljs-params">text</span>) =&gt; &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">text</span> = text;<br>&#125;;<br><br><span class="hljs-keyword">var</span> helloMessage = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Message</span>(<span class="hljs-string">&#x27;Hello World!&#x27;</span>);<br><span class="hljs-comment">// Uncaught TypeError: Message is not a constructor</span><br></code></pre></td></tr></table></figure><p>解析：从报错信息可以看出，箭头函数没有 constructor 方法，所以不能用作构造函数。 JavaScript 会通过抛出异常的方式，进行隐式地预防。</p><p>解决方法：用函数表达式代替箭头函数。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>回顾 MDN 给出的解释：箭头函数表达式的语法比函数表达式更短，并且<code>没有自己的this，arguments，super或 new.target</code>。这些函数表达式更适用于那些本来需要匿名函数的地方，并且它们不能用作构造函数。</p><p>所以说，箭头函数无疑是 ES6 带来的重大改进，在正确的场合使用箭头函数，能让代码变得更加简洁短小。但箭头函数也不是万能的，不能用的时候，千万别硬往上套。比如，<strong>在需要动态上下文的场景中，使用箭头函数需要格外地小心，这些场景包括：对象的方法、原型方法、事件的回调、构造函数</strong>。并非一定要用箭头函数，才能解决问题。</p><ol><li>箭头函数适合与 <code>this 无关的回调. 定时器, 数组的方法回调</code></li><li>箭头函数不适合与 this 有关的回调. <code>事件回调, 对象的方法</code></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> 箭头函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this.$refs[‘form‘].resetFields()方法重置表单无效的坑</title>
      <link href="/2022/12/09/this.$refs%5B%E2%80%98form%E2%80%98%5D.resetFields()%E6%96%B9%E6%B3%95%E9%87%8D%E7%BD%AE%E8%A1%A8%E5%8D%95%E6%97%A0%E6%95%88%E7%9A%84%E5%9D%91/"/>
      <url>/2022/12/09/this.$refs%5B%E2%80%98form%E2%80%98%5D.resetFields()%E6%96%B9%E6%B3%95%E9%87%8D%E7%BD%AE%E8%A1%A8%E5%8D%95%E6%97%A0%E6%95%88%E7%9A%84%E5%9D%91/</url>
      
        <content type="html"><![CDATA[<h1 id="this-refs-‘form’-resetFields-方法重置表单无效的坑"><a href="#this-refs-‘form’-resetFields-方法重置表单无效的坑" class="headerlink" title="this.$refs[‘form’].resetFields()方法重置表单无效的坑"></a>this.$refs[‘form’].resetFields()方法重置<a href="https://so.csdn.net/so/search?q=%E8%A1%A8%E5%8D%95&amp;spm=1001.2101.3001.7020">表单</a>无效的坑</h1><h2 id="1、用法不对"><a href="#1、用法不对" class="headerlink" title="1、用法不对"></a>1、用法不对</h2><p>要想this.$refs[‘form’].resetFields()方法有效，必须配置el-form :<a href="https://so.csdn.net/so/search?q=model&amp;spm=1001.2101.3001.7020">model</a> 属性和el-form-item中的prop属性，才可以。</p><p>注意：this.$refs[‘form’].resetFields()这个做法其实是重置表单到初始值，不是清空表单，当表单第一次在页面中渲染时所用的数据就是初始数据。</p><h2 id="2、坑1"><a href="#2、坑1" class="headerlink" title="2、坑1"></a>2、坑1</h2><p>在还没有显示对话框之前就调用this.$refs[‘form’].resetFields()，会报错。</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">this.$nextTick(() =&gt; &#123;<br>    this.$refs[&#x27;form&#x27;].resetFields();<br>&#125;);<br></code></pre></td></tr></table></figure><p>3、坑2</p><p>如果添加和修改共用一个表单时就会出现重置无效的情况。</p><p>解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">this.$nextTick(() =&gt; &#123;<br>    utils.copyFormObject(data, this.form);<br>&#125;);<br></code></pre></td></tr></table></figure><p>将为表单对象赋值的操作放在对话框显示之后的一个执行周期执行。</p><p>4、为什么要放在$nextTick()中就可以了</p><p>this.$refs[‘form’].resetFields()这个做法其实是重置表单到初始值，不是清空表单，当表单第一次在页面中渲染时所用的数据就是初始数据，如果修改对象的表单赋值没有放在nextTick中，就会在表单渲染时就会将这个修改对象作为初始值，所以出现无效了。使用nextTick保证表单在第一次渲染时是空值就可以了。</p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> element </tag>
            
            <tag> 坑 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6三种暴露方法详解</title>
      <link href="/2022/12/09/ES6%E4%B8%89%E7%A7%8D%E6%9A%B4%E9%9C%B2%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/2022/12/09/ES6%E4%B8%89%E7%A7%8D%E6%9A%B4%E9%9C%B2%E6%96%B9%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h4 id="多行暴露"><a href="#多行暴露" class="headerlink" title="多行暴露"></a>多行暴露</h4><p>导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//a.js<br><br>export function aa1()&#123;<br>    console.log(&#x27;分别导出1&#x27;);<br>&#125;<br>export function aa2()&#123;<br>    console.log(&#x27;分别导出2&#x27;);<br>&#125;<br></code></pre></td></tr></table></figure><p>导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//index.js<br><br>//解构赋值<br>import &#123; aa1 , aa2 &#125; from &#x27;a.js&#x27;<br></code></pre></td></tr></table></figure><h4 id="统一暴露"><a href="#统一暴露" class="headerlink" title="统一暴露"></a>统一暴露</h4><p>导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//b.js<br><br>function bb1()&#123;<br>    console.log(&#x27;综合导出1&#x27;);<br>&#125;<br>function bb2()&#123;<br>    console.log(&#x27;综合导出2&#x27;);<br>&#125;<br><br>export &#123;bb1,bb2&#125;<br></code></pre></td></tr></table></figure><p>导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//index.js<br><br>//解构赋值<br>import &#123;aa1,aa2&#125; from &#x27;b.js&#x27;<br></code></pre></td></tr></table></figure><h4 id="默认暴露"><a href="#默认暴露" class="headerlink" title="默认暴露"></a>默认暴露</h4><p>导出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//c.js<br><br>export default function cc()&#123;<br>    console.log(&#x27;默认导出&#x27;);<br>&#125;<br></code></pre></td></tr></table></figure><p>导入</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//index.js<br><br>//使用定义变量<br>import c from &#x27;c.js&#x27;<br>c.cc()<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> es6 </tag>
            
            <tag> js </tag>
            
            <tag> commonJs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AJAX的学习笔记(Node.js环境)</title>
      <link href="/2022/12/09/AJAX%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Node.js%E7%8E%AF%E5%A2%83)/"/>
      <url>/2022/12/09/AJAX%E7%9A%84%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0(Node.js%E7%8E%AF%E5%A2%83)/</url>
      
        <content type="html"><![CDATA[<h1 id="AJAX的学习笔记-Node-js环境"><a href="#AJAX的学习笔记-Node-js环境" class="headerlink" title="AJAX的学习笔记(Node.js环境)"></a>AJAX的学习笔记(Node.js环境)</h1><p>AJAX学习的笔记，主要环境为Node.js</p><p>课程地址： <a href="https://www.bilibili.com/video/BV1WC4y1b78y">https://www.bilibili.com/video/BV1WC4y1b78y</a></p><h2 id="第一章-Ajax概述"><a href="#第一章-Ajax概述" class="headerlink" title="第一章 Ajax概述"></a>第一章 Ajax概述</h2><h3 id="1-1-Ajax简介"><a href="#1-1-Ajax简介" class="headerlink" title="1.1 Ajax简介"></a>1.1 Ajax简介</h3><ul><li>Ajax即Asynchronous Javascript And XML（异步JavaScript和XML）</li><li>通过Ajax可以在浏览器中向服务器发送异步请求，最大的优势：<strong>无刷新获取数据</strong></li><li>AJAX不是新的编程语言，而是一种将现有的标准组合在一起使用的新方式</li></ul><h3 id="1-2-XML简介"><a href="#1-2-XML简介" class="headerlink" title="1.2 XML简介"></a>1.2 XML简介</h3><ul><li>XML：可扩展标记语言</li><li>XML：被设计用来传输和存储数据</li><li>XML和HTML类似，不同点：HTML中都是预定义标签，XML中没有预定义标签，全是自定义标签，用来表示一些数据</li><li>现在已被JSON取代</li></ul><h3 id="1-3-AJAX-的特点"><a href="#1-3-AJAX-的特点" class="headerlink" title="1.3 AJAX 的特点"></a>1.3 AJAX 的特点</h3><h4 id="1-3-1-AJAX的优点"><a href="#1-3-1-AJAX的优点" class="headerlink" title="1.3.1 AJAX的优点"></a>1.3.1 AJAX的优点</h4><ol><li>可以无刷新页面与服务端进行通信</li><li>允许你根据用户事件来更新部分页面内容</li></ol><h4 id="1-3-2-AJAX-的缺点"><a href="#1-3-2-AJAX-的缺点" class="headerlink" title="1.3.2 AJAX 的缺点"></a>1.3.2 AJAX 的缺点</h4><ol><li>没有浏览历史，不能回退</li><li>存在跨域问题（同源）</li><li>SEO不友好（爬虫获取不到信息）</li></ol><h2 id="第二章-原生AJAX"><a href="#第二章-原生AJAX" class="headerlink" title="第二章 原生AJAX"></a>第二章 原生AJAX</h2><h3 id="2-1-HTTP"><a href="#2-1-HTTP" class="headerlink" title="2.1 HTTP"></a>2.1 HTTP</h3><p><strong>约定, 规则</strong><br>HTTP（hypertext transport protocol）协议『超文本传输协议』，协议详细规定了浏览器和万维网服务器之间互相通信的规则。</p><h4 id="2-1-1-请求报文"><a href="#2-1-1-请求报文" class="headerlink" title="2.1.1 请求报文"></a>2.1.1 请求报文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">行      POST  /s?ie=utf-8  HTTP/1.1 <br>头      Host: atguigu.com<br>        Cookie: name=guigu<br>        Content-type: application/x-www-form-urlencoded<br>        User-Agent: chrome 83<br>空行<br>体      username=admin&amp;password=admin<br></code></pre></td></tr></table></figure><h4 id="2-1-2-响应报文"><a href="#2-1-2-响应报文" class="headerlink" title="2.1.2 响应报文"></a>2.1.2 响应报文</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">行      HTTP/1.1  200  OK<br>头      Content-Type: text/html;charset=utf-8<br>        Content-length: 2048<br>        Content-encoding: gzip<br>空行    <br>体      &lt;html&gt;<br>            &lt;head&gt;<br>            &lt;/head&gt;<br>            &lt;body&gt;<br>                &lt;h1&gt;尚硅谷&lt;/h1&gt;<br>            &lt;/body&gt;<br>        &lt;/html&gt;<br></code></pre></td></tr></table></figure><h3 id="2-2-express框架的基本使用"><a href="#2-2-express框架的基本使用" class="headerlink" title="2.2 express框架的基本使用"></a>2.2 express框架的基本使用</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//1. 引入express<br>const express = require(&#x27;express&#x27;);<br><br>//2. 创建应用对象<br>const app = express();<br><br>//3. 创建路由规则<br>// request 是对请求报文的封装<br>// response 是对响应报文的封装<br>app.get(&#x27;/&#x27;, (request, response)=&gt;&#123;<br>    //设置响应<br>    response.send(&#x27;HELLO EXPRESS&#x27;);<br>&#125;);<br><br>//4. 监听端口启动服务<br>app.listen(8000, ()=&gt;&#123;<br>    console.log(&quot;服务已经启动, 8000 端口监听中....&quot;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-3-Ajax-GET请求"><a href="#2-3-Ajax-GET请求" class="headerlink" title="2.3 Ajax GET请求"></a>2.3 Ajax GET请求</h3><ul><li>前端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//1. 创建对象<br>const xhr = new XMLHttpRequest();<br>//2. 初始化 设置请求方法和 url<br>xhr.open(&#x27;GET&#x27;, &#x27;http://127.0.0.1:8000/server?a=100&amp;b=200&amp;c=300&#x27;);<br>//3. 发送<br>xhr.send();<br>//4. 事件绑定 处理服务端返回的结果<br>// on  when 当....时候<br>// readystate 是 xhr 对象中的属性, 表示状态 0 1 2 3 4<br>// change  改变<br>xhr.onreadystatechange = function()&#123;<br>    //判断 (服务端返回了所有的结果)<br>    if(xhr.readyState === 4)&#123;<br>        //判断响应状态码 200  404  403 401 500<br>        // 2xx 成功<br>        if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;<br>            //处理结果  行 头 空行 体<br>            //响应 <br>            // console.log(xhr.status);//状态码<br>            // console.log(xhr.statusText);//状态字符串<br>            // console.log(xhr.getAllResponseHeaders());//所有响应头<br>            // console.log(xhr.response);//响应体<br>            //设置 result 的文本<br>            result.innerHTML = xhr.response;<br>        &#125;else&#123;<br><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//1. 引入express<br>const express = require(&#x27;express&#x27;);<br><br>//2. 创建应用对象<br>const app = express();<br><br>//3. 创建路由规则<br>// request 是对请求报文的封装<br>// response 是对响应报文的封装<br>app.get(&#x27;/server&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    //设置响应体<br>    response.send(&#x27;HELLO AJAX - 2&#x27;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-4-Ajax-POST-请求"><a href="#2-4-Ajax-POST-请求" class="headerlink" title="2.4 Ajax POST 请求"></a>2.4 Ajax POST 请求</h3><ul><li>前端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//1. 创建对象<br> const xhr = new XMLHttpRequest();<br> //2. 初始化 设置类型与 URL<br> xhr.open(&#x27;POST&#x27;, &#x27;http://127.0.0.1:8000/server&#x27;);<br> //设置请求头  Content-Type 设置请求体（参数查询字符串）的类型<br> xhr.setRequestHeader(&#x27;Content-Type&#x27;,&#x27;application/x-www-form-urlencoded&#x27;);<br> xhr.setRequestHeader(&#x27;name&#x27;,&#x27;atguigu&#x27;);<br> //3. 发送 携带参数 请求体<br> xhr.send(&#x27;a=100&amp;b=200&amp;c=300&#x27;);<br> // xhr.send(&#x27;a:100&amp;b:200&amp;c:300&#x27;);<br> // xhr.send(&#x27;1233211234567&#x27;);<br><br> //4. 事件绑定<br> xhr.onreadystatechange = function()&#123;<br>     //判断<br>     if(xhr.readyState === 4)&#123;<br>         if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;<br>             //处理服务端返回的结果<br>             result.innerHTML = xhr.response;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//可以接收任意类型的请求 <br>app.all(&#x27;/server&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    //响应头<br>    response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);<br>    //设置响应体<br>    response.send(&#x27;HELLO AJAX POST&#x27;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-5-JSON-响应"><a href="#2-5-JSON-响应" class="headerlink" title="2.5 JSON 响应"></a>2.5 JSON 响应</h3><ul><li>前端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//发送请求<br> const xhr = new XMLHttpRequest();<br> //设置响应体数据的类型<br> xhr.responseType = &#x27;json&#x27;;<br> //初始化<br> xhr.open(&#x27;GET&#x27;,&#x27;http://127.0.0.1:8000/json-server&#x27;);<br> //发送<br> xhr.send();<br> //事件绑定<br> xhr.onreadystatechange = function()&#123;<br>     if(xhr.readyState === 4)&#123;<br>         if(xhr.status &gt;= 200 &amp;&amp; xhr.status &lt; 300)&#123;<br>             //<br>             // console.log(xhr.response);<br>             // result.innerHTML = xhr.response;<br>             // 1. 手动对数据转化<br>             // let data = JSON.parse(xhr.response);<br>             // console.log(data);<br>             // result.innerHTML = data.name;<br>             // 2. 自动转换<br>             console.log(xhr.response);<br>             result.innerHTML = xhr.response.name;<br>         &#125;<br>     &#125;<br> &#125;<br></code></pre></td></tr></table></figure><ul><li>服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//JSON 响应<br>app.all(&#x27;/json-server&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    //响应头<br>    response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);<br>    //响应一个数据<br>    const data = &#123;<br>        name: &#x27;atguigu&#x27;<br>    &#125;;<br>    //对对象进行字符串转换<br>    let str = JSON.stringify(data);<br>    //设置响应体<br>    response.send(str);<br>&#125;);<br><br></code></pre></td></tr></table></figure><h3 id="2-6-IE缓存问题"><a href="#2-6-IE缓存问题" class="headerlink" title="2.6 IE缓存问题"></a>2.6 IE缓存问题</h3><ul><li>前端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const xhr = new XMLHttpRequest();<br>xhr.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/ie?t=&#x27;+Date.now());<br>xhr.send();<br>xhr.onreadystatechange = function()&#123;<br>    if(xhr.readyState === 4)&#123;<br>        if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300)&#123;<br>            result.innerHTML = xhr.response;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//针对 IE 缓存<br>app.get(&#x27;/ie&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    //设置响应体<br>    response.send(&#x27;HELLO IE - 5&#x27;);<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-7-超时与网络异常"><a href="#2-7-超时与网络异常" class="headerlink" title="2.7 超时与网络异常"></a>2.7 超时与网络异常</h3><ul><li>前端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">const xhr = new XMLHttpRequest();<br>//超时设置 2s 设置<br>xhr.timeout = 2000;<br>//超时回调<br>xhr.ontimeout = function()&#123;<br>    alert(&quot;网络异常, 请稍后重试!!&quot;);<br>&#125;<br>//网络异常回调<br>xhr.onerror = function()&#123;<br>    alert(&quot;你的网络似乎出了一些问题!&quot;);<br>&#125;<br><br>xhr.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;);<br>xhr.send();<br>xhr.onreadystatechange = function()&#123;<br>    if(xhr.readyState === 4)&#123;<br>        if(xhr.status &gt;= 200 &amp;&amp; xhr.status&lt; 300)&#123;<br>            result.innerHTML = xhr.response;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//延时响应<br>app.all(&#x27;/delay&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);<br>    setTimeout(() =&gt; &#123;<br>        //设置响应体<br>        response.send(&#x27;延时响应&#x27;);<br>    &#125;, 1000)<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="2-8-取消请求"><a href="#2-8-取消请求" class="headerlink" title="2.8 取消请求"></a>2.8 取消请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">x = new XMLHttpRequest();<br>x.abort();<br></code></pre></td></tr></table></figure><h3 id="2-9-重复请求问题"><a href="#2-9-重复请求问题" class="headerlink" title="2.9 重复请求问题"></a>2.9 重复请求问题</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//获取元素对象<br>const btns = document.querySelectorAll(&#x27;button&#x27;);<br>let x = null;<br>//标识变量<br>let isSending = false; // 是否正在发送AJAX请求<br><br>btns[0].onclick = function()&#123;<br>    //判断标识变量<br>    if(isSending) x.abort();// 如果正在发送, 则取消该请求, 创建一个新的请求<br>    x = new XMLHttpRequest();<br>    //修改 标识变量的值<br>    isSending = true;<br>    x.open(&quot;GET&quot;,&#x27;http://127.0.0.1:8000/delay&#x27;);<br>    x.send();<br>    x.onreadystatechange = function()&#123;<br>        if(x.readyState === 4)&#123;<br>            //修改标识变量<br>            isSending = false;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="第三章-jQuery中的AJAX"><a href="#第三章-jQuery中的AJAX" class="headerlink" title="第三章 jQuery中的AJAX"></a>第三章 jQuery中的AJAX</h2><h3 id="3-1-get请求"><a href="#3-1-get请求" class="headerlink" title="3.1 get请求"></a>3.1 get请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$.get(url, [data], [callback], [type])<br>url: 请求的URL地址<br>data: 请求携带的参数<br>callback: 载入成功时回调函数<br>type：设置返回内容格式，xml、html、script、json、text、_default<br></code></pre></td></tr></table></figure><h3 id="3-2-post请求"><a href="#3-2-post请求" class="headerlink" title="3.2 post请求"></a>3.2 post请求</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$.post(url,[data],[callback],[type]<br>url:请求的URL地址<br>data:请求携带的参数<br>callback:载入成功时的回调函数<br>type:设置返回内容格式，xml,html,script,json,text,__default<br></code></pre></td></tr></table></figure><h3 id="3-3-通用型方法ajax"><a href="#3-3-通用型方法ajax" class="headerlink" title="3.3 通用型方法ajax"></a>3.3 通用型方法ajax</h3><ul><li>前端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">$(&#x27;button&#x27;).eq(2).click(function()&#123;<br>$.ajax(&#123;<br>    //url<br>    url: &#x27;http://127.0.0.1:8000/jquery-server&#x27;,<br>    //参数<br>    data: &#123;a:100, b:200&#125;,<br>    //请求类型<br>    type: &#x27;GET&#x27;,<br>    //响应体结果<br>    dataType: &#x27;json&#x27;,<br>    //成功的回调<br>    success: function(data)&#123;<br>        console.log(data);<br>    &#125;,<br>    //超时时间<br>    timeout: 2000,<br>    //失败的回调<br>    error: function()&#123;<br>        console.log(&#x27;出错啦!!&#x27;);<br>    &#125;,<br>    //头信息<br>    headers: &#123;<br>        c:300,<br>        d:400<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>服务器</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//jQuery 服务<br>app.all(&#x27;/jquery-server&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);<br>    // response.send(&#x27;Hello jQuery AJAX&#x27;);<br>    const data = &#123;name:&#x27;尚硅谷&#x27;&#125;;<br>    response.send(JSON.stringify(data));<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="第四章-axios"><a href="#第四章-axios" class="headerlink" title="第四章 axios"></a>第四章 axios</h2><h3 id="4-1-GET"><a href="#4-1-GET" class="headerlink" title="4.1 GET"></a>4.1 GET</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//GET 请求<br>axios.get(&#x27;/axios-server&#x27;, &#123;<br>     //url 参数<br>     params: &#123;<br>         id: 100,<br>         vip: 7<br>     &#125;,<br>     //请求头信息<br>     headers: &#123;<br>         name: &#x27;atguigu&#x27;,<br>         age: 20<br>     &#125;<br> &#125;).then(value =&gt; &#123;<br>     console.log(value);<br> &#125;);<br></code></pre></td></tr></table></figure><h3 id="4-2-POST"><a href="#4-2-POST" class="headerlink" title="4.2 POST"></a>4.2 POST</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">axios.post(&#x27;/axios-server&#x27;, &#123;<br>    username: &#x27;admin&#x27;,<br>    password: &#x27;admin&#x27;<br>&#125;, &#123;<br>    //url <br>    params: &#123;<br>        id: 200,<br>        vip: 9<br>    &#125;,<br>    //请求头参数<br>    headers: &#123;<br>        height: 180,<br>        weight: 180,<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-3-通用型"><a href="#4-3-通用型" class="headerlink" title="4.3 通用型"></a>4.3 通用型</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">axios(&#123;<br>    //请求方法<br>    method : &#x27;POST&#x27;,<br>    //url<br>    url: &#x27;/axios-server&#x27;,<br>    //url参数<br>    params: &#123;<br>        vip:10,<br>        level:30<br>    &#125;,<br>    //头信息<br>    headers: &#123;<br>        a:100,<br>        b:200<br>    &#125;,<br>    //请求体参数<br>    data: &#123;<br>        username: &#x27;admin&#x27;,<br>        password: &#x27;admin&#x27;<br>    &#125;<br>&#125;).then(response=&gt;&#123;<br>    //响应状态码<br>    console.log(response.status);<br>    //响应状态字符串<br>    console.log(response.statusText);<br>    //响应头信息<br>    console.log(response.headers);<br>    //响应体<br>    console.log(response.data);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="4-4-服务器端"><a href="#4-4-服务器端" class="headerlink" title="4.4 服务器端"></a>4.4 服务器端</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//axios 服务<br>app.all(&#x27;/axios-server&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);<br>    // response.send(&#x27;Hello jQuery AJAX&#x27;);<br>    const data = &#123;name:&#x27;尚硅谷&#x27;&#125;;<br>    response.send(JSON.stringify(data));<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="第五章-fetch"><a href="#第五章-fetch" class="headerlink" title="第五章 fetch"></a>第五章 fetch</h2><ul><li>前端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">fetch(&#x27;http://127.0.0.1:8000/fetch-server?vip=10&#x27;, &#123;<br>    //请求方法<br>    method: &#x27;POST&#x27;,<br>    //请求头<br>    headers: &#123;<br>        name:&#x27;atguigu&#x27;<br>    &#125;,<br>    //请求体<br>    body: &#x27;username=admin&amp;password=admin&#x27;<br>&#125;).then(response =&gt; &#123;<br>    // return response.text();<br>    return response.json();<br>&#125;).then(response=&gt;&#123;<br>    console.log(response);<br>&#125;);<br></code></pre></td></tr></table></figure><ul><li>服务器端</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">//fetch 服务<br>app.all(&#x27;/fetch-server&#x27;, (request, response) =&gt; &#123;<br>    //设置响应头  设置允许跨域<br>    response.setHeader(&#x27;Access-Control-Allow-Origin&#x27;, &#x27;*&#x27;);<br>    response.setHeader(&#x27;Access-Control-Allow-Headers&#x27;, &#x27;*&#x27;);<br>    // response.send(&#x27;Hello jQuery AJAX&#x27;);<br>    const data = &#123;name:&#x27;尚硅谷&#x27;&#125;;<br>    response.send(JSON.stringify(data));<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="第六章：-跨域"><a href="#第六章：-跨域" class="headerlink" title="第六章： 跨域"></a>第六章： 跨域</h2><h3 id="6-1-同源策略"><a href="#6-1-同源策略" class="headerlink" title="6.1 同源策略"></a>6.1 同源策略</h3><p>同源策略（Same-Origin Policy）最早由 Netscape 公司提出，是浏览器的一种安全策略。</p><p>同源：协议、域名、端口号 必须完全相同</p><p>违背同源策略就是跨域</p><h3 id="6-2-如何解决跨域"><a href="#6-2-如何解决跨域" class="headerlink" title="6.2 如何解决跨域"></a>6.2 如何解决跨域</h3><h4 id="6-2-1-JSONP"><a href="#6-2-1-JSONP" class="headerlink" title="6.2.1 JSONP"></a>6.2.1 JSONP</h4><ol><li><p>JSONP是什么</p><p>JSONP (JSON with Padding)，是一个非官方的跨域解决方案，纯粹凭借程序员的聪明才智开发出来，只支持get请求</p></li><li><p>JSONP 怎么工作的？</p><p>在网页有一些标签天生具有跨域能力，比如：img, link, iframe, script</p><p>JSONP就是利用<strong>script</strong>标签的跨域能力来发送请求的</p><ol><li>JSONP的使用</li></ol><ul><li>动态的创建一个script标签</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">var script = document.createElement(&quot;script&quot;);<br></code></pre></td></tr></table></figure><ul><li>设置script的src，设置回调函数</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">script.src = &quot;http://locallhost:3000/textAJAX?callback=abc&quot;<br></code></pre></td></tr></table></figure><h3 id="6-2-2-CORS"><a href="#6-2-2-CORS" class="headerlink" title="6.2.2 CORS"></a>6.2.2 CORS</h3><p>推荐阅读：</p><ul><li><a href="http://www.ruanyifeng.com/blog/2016/04/cors.html">http://www.ruanyifeng.com/blog/2016/04/cors.html</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access\_control\_CORS">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access\_control\_CORS</a></li></ul><ol><li><p>CORS是什么？</p><p>CORS (Cross-Origin Resource Sharing), 跨域资源共享。CORS 是官方的跨域解决方案，它的特点是不需要在客户端做任何特殊的操作，完全在服务器中进行处理，支持 get 和 post 等请求。跨域资源共享标准新增了一组 HTTP 首部字段（响应头），允许服务器声明哪些源站通过浏览器有权限访问哪些资源</p></li><li><p>CORS怎么工作的？</p><p>CORS 是通过设置一个响应头来告诉浏览器，该请求允许跨域，浏览器收到该响应以后就会对响应放行。</p></li><li><p>CORS 的使用</p><p>主要是服务端的设置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">rounter.get(&quot;/testAJAX&quot;,function(req, res)&#123;<br><br>&#125;)<br></code></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ajax </tag>
            
            <tag> axios </tag>
            
            <tag> http </tag>
            
            <tag> json </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo搭建博客</title>
      <link href="/2022/12/07/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/12/07/Hexo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>在开始教程之前，你可以了解一下使用gitee pages服务搭建博客有哪些好处：</p><ul><li>gitee 是国内的网站，相较于 github 访问速度更快；</li><li>全是静态文件，访问速度快；</li><li>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</li><li>数据绝对安全，基于gitee的版本管理，想恢复到哪个历史版本都行；</li><li>博客内容可以轻松打包、转移、发布到其它平台；</li><li>等等。</li></ul><h2 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h2><p>在开始一切之前，你必须已经：</p><ul><li>有一个gitee账号，没有的话去注册一个（邮箱注册，需要验证）；</li><li>安装了node.js并了解相关基础知识（主要用于安装hexo依赖）；</li><li>安装了git for windows（或者其它git客户端）</li></ul><p>注册地址：<a href="https://gitee.com/">码云</a><br>本文所使用的环境：</p><ul><li>Windows10 v1909</li><li>node.js v12.4.0</li><li>git v2.24.1</li><li>hexo v4.2.0</li></ul><h2 id="2-环境搭建"><a href="#2-环境搭建" class="headerlink" title="2. 环境搭建"></a>2. 环境搭建</h2><h3 id="2-1-环境检查"><a href="#2-1-环境检查" class="headerlink" title="2.1. 环境检查"></a>2.1. 环境检查</h3><p>首先，nodejs、git的安装过程省略。主要要说的是<a href="https://so.csdn.net/so/search?q=hexo&amp;spm=1001.2101.3001.7020">hexo</a>的安装和配置。<br>安装好上面几个后，我们就可以开始 hexo 的配置了。<br>接下来，我们先测试一下是否成功安装了。</p><ul><li>按 win + R 键，输入 cmd 打开命令行</li><li>输入 <code>git --version</code>，如果安装成功会提示一些 git 的版本号信息<ul><li>比如 git 版本是 2.24.1 ，那么就会显示 <code>git version 2.24.1.windows.2</code></li></ul></li><li>同理，输入 <code>npm -v</code>，也会显示 npm 的版本信息<br>现在我们可以开始我们环境的搭建了。</li></ul><h3 id="2-2-搭建Hexo框架"><a href="#2-2-搭建Hexo框架" class="headerlink" title="2.2. 搭建Hexo框架"></a>2.2. 搭建Hexo框架</h3><p>第一步，我们可以先配置 npm 的国内源，然后后面的所有 <code>npm ...</code>命令都可以改成 <code>cnpm ...</code>，改成国内源的好处就是下载会很快，不会被墙。</p><pre><code>$ npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>然后等待安装完成，这个过程可能也点久，耐心等待一下就好了。<br>安装好之后，接下来就是正式的第一步了，在命令行界面，输入</p><pre><code>npm install -g hexo         # 通过npm全局安装hexo</code></pre><p>其中，-g 指定全局安装，之后可以在任意位置使用 hexo 命令<br>接下来，进入到你要放博客的静态文件的位置，右键，选择 Git Bash Here，打开 Git Bash 之后，输入</p><pre><code>hexo init blog      # 初始化创建，会在你所在位置创建 blog 文件夹cd blog             # 进入 blog 目录npm install         # 进一步安装hexo所需文件</code></pre><p>等待 hexo 安装完成。。。<br>安装完成后，会出现一下这些文件夹以及文件<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421264.png" alt="hexo自动文件夹以及文件"></p><p>其中 source 就是存放后面我们写博客的源文件的文件夹<br>接下来输入</p><pre><code>hexo clean          # 清除所有记录hexo generate       # 生成静态网页hexo server -p 80   # 启动服务, -p 80 表示端口号为 80，默认不加端口号是 4000</code></pre><p>然后，使用浏览器访问：<code>http://localhost:80</code>，就可以看到下面的界面了<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421636.png" alt="默认的hexo界面"></p><h3 id="2-3-安装配置主题"><a href="#2-3-安装配置主题" class="headerlink" title="2.3. 安装配置主题"></a>2.3. 安装配置主题</h3><p>如果你不喜欢现在的主题样式可以选择换一个，首先是 <a href="https://hexo.io/themes/">官方主题</a>，可以在里面下载自己喜欢的主题。<br>个人现在使用的是 hexo-theme-butterfly。<br>这里就以这个主题为例：<br>先按 Ctrl + C,断开刚刚的服务，然后输入</p><pre><code>git clone -b dev https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</code></pre><p>下载后的主题在 themes 里面，如图：  </p><p><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421217.png" alt="在这里插入图片描述"></p><p>回到 blog 文件夹，用记事本打开 <code>_config.yml</code> ,修改里面的 <code>theme: landscape</code> 为 <code>theme: butterfly</code><br>之后重新输入</p><pre><code>hexo clean          # 清除所有记录hexo generate       # 生成静态网页hexo s              # 启动服务</code></pre><p>然后，使用浏览器访问：<code>http://localhost:4000</code>，就可以看到新的界面了。</p><p>如果这里打开网址报错了，根据提示需要安装渲染器插件</p><p><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421355.png" alt="在这里插入图片描述"></p><p>安装渲染器插件</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">npm install --save hexo-renderer-jade hexo-generator-feed hexo-generator-sitemap hexo-browsersync hexo-generator-archive<br></code></pre></td></tr></table></figure><p>安装完插件再次执行“hexo三连”就可以了</p><h3 id="2-4-解决图片路径问题"><a href="#2-4-解决图片路径问题" class="headerlink" title="2.4. 解决图片路径问题"></a>2.4. 解决图片路径问题</h3><p>由于 Gitee 和 <a href="https://so.csdn.net/so/search?q=Github&amp;spm=1001.2101.3001.7020">Github</a> 不太一样，并且 hexo 3.0 之后获取 url 的方式也不一样了，所以为了解决图片的路径问题，我们需要先安装一个插件。<br>先按 Ctrl + C,断开刚刚的服务，然后输入</p><pre><code>npm install hexo-asset-image --save  #安装 hexo-asset-image 插件</code></pre><p>接下来还需要修改一下 <code>_config.yml</code></p><pre><code>……post_asset_folder: true……</code></pre><p>之后你要博客只需输入</p><pre><code>hexo new test       # 生成新的网页</code></pre><p>就会在 <code>source/_posts</code> 下，会同时生成test目录和test.md 网页，将需要的图片放置到test目录下，test.md就可以正常解析了。如图：<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421699.png" alt="生成对应的文件夹"></p><p>除此之外还建议使用picgo图床的方式放置图片</p><p>方法详见 PicGo 安装及配置.md</p><h2 id="3-配置gitee仓库"><a href="#3-配置gitee仓库" class="headerlink" title="3. 配置gitee仓库"></a>3. 配置gitee仓库</h2><h3 id="3-1-创建仓库"><a href="#3-1-创建仓库" class="headerlink" title="3.1. 创建仓库"></a>3.1. 创建仓库</h3><p>新建一个仓库,用于存放你的博客的相关文件的，推荐仓库名和用户名一样，这样可以省去后面的很多路径问题。<br>几个注意的地方：</p><ul><li>注册的邮箱一定要验证，否则不会成功；</li><li>推荐仓库名和用户名一样，这样后面可减少出现路径问题导致的 CSS 样式不加载、图片不显示问题；</li></ul><p>创建成功后，默认会在你这个仓库里生成一些示例页面，以后你的网站所有代码都是放在这个仓库里啦。</p><h3 id="3-2-绑定域名"><a href="#3-2-绑定域名" class="headerlink" title="3.2. 绑定域名"></a>3.2. 绑定域名</h3><p>如果你有条件的话，可以申请域名并绑定，这里先不说了。</p><h3 id="3-3-配置SSH-key"><a href="#3-3-配置SSH-key" class="headerlink" title="3.3. 配置SSH key"></a>3.3. 配置SSH key</h3><p>为什么要配置这个呢？因为你提交代码肯定要拥有你的 gitee 权限才可以，但是直接使用用户名和密码太不安全了，所以我们使用ssh key来解决本地和服务器的连接问题。<br>先输入</p><pre><code>cd ~/.ssh #检查本机是否已存在的ssh密钥</code></pre><p>如果提示：<code>No such file or directory</code>说明你是第一次使用git，如果什么都没有提示，说明本地已经配置了ssh密钥了</p><pre><code>ssh-keygen -t rsa -C &quot;邮件地址&quot;</code></pre><p>然后连续3次回车，最终会生成一个文件在用户目录下。<br>打开用户目录（C:\用户\你的用户名\），找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容。<br>打开你的gitee主页，右上角头像那里选择<code>设置</code> → <code>SSH公钥</code>，<br>将刚复制的内容粘贴到<code>公钥</code>那里，<code>标题</code>随便填，填完点击确定。<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421604.png" alt="公钥的创建"></p><h3 id="3-4-测试是否成功"><a href="#3-4-测试是否成功" class="headerlink" title="3.4. 测试是否成功"></a>3.4. 测试是否成功</h3><pre><code>ssh -T git@gitee.com  #注意，&#39;T&#39;是大写的</code></pre><p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p><blockquote><p>Hi 你的gitee用户名! You’ve successfully authenticated, but GITEE.COM does not provide shell access.</p></blockquote><p>比如我的就是</p><blockquote><p>Hi chongqing0111! You’ve successfully authenticated, but GITEE.COM does not provide shell access.</p></blockquote><p>看到这个信息说明SSH已配置成功！<br>接下来还需要配置用户名和邮箱：</p><pre><code>git config --global user.name &quot;xxx&quot;  #你的 gitee 用户名，即注册时的用户名，个人主页最大那个就是了git config --global user.email  &quot;xxx@qq.com&quot;  #填写你的github注册邮箱</code></pre><h2 id="4-部署博客到Gitee"><a href="#4-部署博客到Gitee" class="headerlink" title="4. 部署博客到Gitee"></a>4. 部署博客到Gitee</h2><h3 id="4-1-hexo简介"><a href="#4-1-hexo简介" class="headerlink" title="4.1. hexo简介"></a>4.1. hexo简介</h3><p>Hexo是一个简单、快速、强大的基于 Gitee Pages 的博客发布工具，支持 Markdown 格式，有众多优秀插件和主题。<br>官网： <a href="http://hexo.io">http://hexo.io</a></p><h3 id="4-2-部署原理"><a href="#4-2-部署原理" class="headerlink" title="4.2. 部署原理"></a>4.2. 部署原理</h3><p>由于gitee pages存放的都是静态文件，博客存放的不只是文章内容，还有文章列表、分类、标签、翻页等动态内容，如果要手动更新博文目录和相关链接信息，就会感觉非常的麻烦，所以 hexo 所做的就是将这些 md 文件都放在本地，每次写完文章后调用写好的命令来批量完成相关页面的生成，然后再将有改动的页面提交到 gitee。</p><h3 id="4-3-注意事项"><a href="#4-3-注意事项" class="headerlink" title="4.3. 注意事项"></a>4.3. 注意事项</h3><p>部署之前先来说几个注意事项：</p><blockquote><ol><li>很多命令既可以用 Windows 的 cmd 来完成，也可以使用 git bash 来完成，但是部分命令会有一些问题，为避免不必要的问题，建议全部使用 git bash 来执行；</li><li>hexo 有2种<code>_config.yml</code>文件，一个是根目录下的全局的<code>_config.yml</code>，一个是各个theme下的；</li></ol></blockquote><h3 id="4-4-上传到-gitee"><a href="#4-4-上传到-gitee" class="headerlink" title="4.4.上传到 gitee"></a>4.4.上传到 gitee</h3><p>如果你一切都配置好了，发布上传很容易，一句 <code>hexo d</code> 就搞定，当然关键还是你要把所有东西配置好。<br>首先，上面的ssh key肯定要配置好。<br>其次，配置_config.yml中有关deploy的部分：</p><pre><code>deploy:  type: git  repo: https://gitee.com/用户名/仓库名  #仓库的地址，比如我的就是：https://gitee.com/chongqing0111/chongqing0111  branch: master</code></pre><p><code>_config.yml</code>这里面都是一些全局配置，每个参数的意思都比较简单明了，所以就不作详细介绍了。<br>需要特别注意的地方是，冒号后面必须有一个空格，否则可能会出问题。</p><p>接下来我们还需要安装一个插件，在 git bash 下输入</p><pre><code>npm install hexo-deployer-git --save</code></pre><p>如果我们没有安装这个插件，此时直接执行 <code>hexo d</code> 的话一般会报如下错误：</p><pre><code>Deployer not found: gitee 或者 Deployer not found: git</code></pre><p>部署这个命令一定要用 git bash，否则会提示<code>Permission denied (publickey)</code>.<br>打开你的 git bash，输入<code>hexo d</code>就会将本次有改动的代码全部提交，没有改动的不会：</p><p>由于hexo默认会把所有md文件都转换成html，包括README.md，所有需要每次生成之后、上传之前，手动将README.md复制到public目录，并删除README.html（没有的可以忽略）。</p><h3 id="4-5-部署Gitee-Pages"><a href="#4-5-部署Gitee-Pages" class="headerlink" title="4.5 部署Gitee Pages"></a>4.5 部署<code>Gitee Pages</code></h3><p>为了让我们的博客其他人可以在网上看到，所以我们需要 <code>gitee</code> 的 <code>Gitee Pages</code> 服务，操作步骤如下：</p><ul><li><p>打开我们的 <code>gitee</code> 上的仓库，然后找到 <code>服务</code> ，然后再找到里面的 <code>Gitee Pages</code> ，点击它。如下图所示：<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421589.png" alt="找到 Gitee Pages"></p></li><li><p>页面跳转之后，往下拉，看到如下图，选择部署的分支（默认为 master）,由于我们直接是部署在根目录的，所以<code>部署分支</code>直接默认，<code>部署目录</code>不用填，最后点击 <code>启动</code> 即可。<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421570.png" alt="启动 Gitee Pages 服务"></p></li></ul><pre><code>部署到GitHub或Gitee上比较类似，但最大的区别就是Gitee Pages 每次推送完最新的一篇文章之后都需要手动更新下，不然访问不到推送的新文章</code></pre><h3 id="4-6-常用hexo命令"><a href="#4-6-常用hexo命令" class="headerlink" title="4.6. 常用hexo命令"></a>4.6. 常用hexo命令</h3><p>常见命令</p><pre><code>hexo new &quot;postName&quot; #新建文章hexo new page &quot;pageName&quot; #新建页面hexo generate #生成静态页面至public目录hexo server #开启预览访问端口（默认端口4000，&#39;ctrl + c&#39;关闭server）hexo deploy #部署到GitHubhexo help  # 查看帮助hexo version  #查看Hexo的版本</code></pre><p>缩写：</p><pre><code>hexo n == hexo newhexo g == hexo generatehexo s == hexo serverhexo d == hexo deploy</code></pre><p>组合命令：</p><pre><code>hexo s -g #生成并本地预览hexo d -g #生成并上传</code></pre><h3 id="4-7-写博客"><a href="#4-7-写博客" class="headerlink" title="4.7. 写博客"></a>4.7. 写博客</h3><p>定位到我们的hexo根目录，执行命令：</p><pre><code>hexo new &#39;我的第一篇博客&#39;</code></pre><p>hexo会帮我们在 <code>source/_posts</code>下生成相关md文件：<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090421983.png" alt="hexo new 生成的文件"></p><p>我们只需要打开这个文件就可以开始写博客了。<br>当然你也可以直接自己新建md文件，用这个命令的好处是帮我们自动生成了时间。<br>一般完整格式如下：</p><pre><code>---title: 文章名称   #文章页面上的显示名称，一般是中文date: 2013-12-02 15:30:16  #文章生成时间，一般不改，当然也可以任意修改categories: 默认分类  #分类tags: [tag1,tag2,tag3]  #文章标签，可空，多标签请用格式，注意:后面有个空格description: 附加一段文章摘要，字数最好在140字以内，会出现在meta的description里面---正文</code></pre><p>​    </p><p>上面我们已经用到了 <code>hexo new ‘postName’</code> 命令了，接下来我们看一下 <code>hexo new page &#39;postName’</code>命令。</p><pre><code>hexo new page &quot;我的第二篇博客&quot;</code></pre><p>生成如下：<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090423910.png" alt="hexo new page 生成的文件"><br>最终部署时生成：<code>hexo\public\我的第二篇博客\index.html</code>，但是它不会作为文章出现在博文目录。</p><p>部署到远端依次执行下列命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">hexo clean  //清一下缓存<br>hexo g  //生成静态文件<br>hexo d  //推送到码云<br><br>hexo cl;hexo g;hexo d<br></code></pre></td></tr></table></figure><p>进入gitee pages页面更新一下就ok了</p><h4 id="4-7-1-写博客工具"><a href="#4-7-1-写博客工具" class="headerlink" title="4.7.1. 写博客工具"></a>4.7.1. 写博客工具</h4><p>那么用什么工具写博客呢？个人使用的是 Typora ，大家有好用的 hexo 写博客工具可以给我推荐一个。</p><h4 id="4-7-2-如何让博文列表不显示全部内容"><a href="#4-7-2-如何让博文列表不显示全部内容" class="headerlink" title="4.7.2. 如何让博文列表不显示全部内容"></a>4.7.2. 如何让博文列表不显示全部内容</h4><p>默认情况下，生成的博文目录会显示全部的文章内容，如何设置文章摘要的长度呢？<br>答案是在合适的位置加上<code>&lt;!--more--&gt;</code>即可，例如：</p><pre><code>## 1. 前言  在开始教程之前，你可以了解一下使用gitee pages服务搭建博客有哪些好处：  * gitee 是国内的网站，相较于 github 访问速度更快；* 全是静态文件，访问速度快；* 免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；&lt;!--more--&gt;* 数据绝对安全，基于gitee的版本管理，想恢复到哪个历史版本都行；* 博客内容可以轻松打包、转移、发布到其它平台；* 等等。</code></pre><p>​    </p><p>结果如图：<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090422288.png" alt="隐藏文章"></p><h3 id="4-9-注意点"><a href="#4-9-注意点" class="headerlink" title="4.9 注意点"></a>4.9 注意点</h3><p>后面我们在博客更新后，上传之后需要手动到你的 Gitee 仓库里面 <code>更新</code> 一下 Gitee Pages。</p><ul><li>打开我们的 <code>gitee</code> 上的仓库，然后找到 <code>服务</code> ，然后再找到里面的 <code>Gitee Pages</code> ，点击它。如下图所示：<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090422133.png" alt="找到 Gitee Pages"></li><li>页面跳转之后，往下拉，看到如下图，选择部署的分支（默认为 master）,由于我们直接是部署在根目录的，所以<code>部署分支</code>直接默认，<code>部署目录</code>不用填，最后点击 <code>更新</code> 即可。<br><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212090422930.png" alt="更新博客"></li></ul>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> 搭建 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>测试文章</title>
      <link href="/2022/11/25/test/"/>
      <url>/2022/11/25/test/</url>
      
        <content type="html"><![CDATA[<h2 id="这是测试文章"><a href="#这是测试文章" class="headerlink" title="这是测试文章"></a>这是测试文章</h2><h3 id="JS常用API"><a href="#JS常用API" class="headerlink" title="JS常用API"></a>JS常用API</h3><h4 id="split"><a href="#split" class="headerlink" title="split()"></a><strong>split()</strong></h4><p>  方法用于指定规则把一个字符串分割成字符串数组。 <strong><em>(字符串———&gt; 字符串数组)</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">stringObject.<span class="hljs-title function_">split</span>(separator,howmany)<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>separator</td><td>必需。字符串或正则表达式，从该参数指定的地方分割 stringObject。</td></tr><tr><td>howmany</td><td>可选。该参数可指定返回的数组的最大长度。如果设置了该参数，返回的子串不会多于这个参数指定的数组。如果没有设置该参数，整个字符串都会被分割，不考虑它的长度。</td></tr></tbody></table></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs JS"><span class="hljs-keyword">var</span> str = <span class="hljs-string">&quot;I lover your too&quot;</span><br><span class="hljs-keyword">var</span> a = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);  <br> <span class="hljs-comment">//不传任何切割标志时，默认切割每一个字符  </span><br> <span class="hljs-comment">//返回[&quot;I&quot;, &quot; &quot;, &quot;l&quot;, &quot;o&quot;, &quot;v&quot;, &quot;e&quot;, &quot;r&quot;, &quot; &quot;, &quot;y&quot;, &quot;o&quot;, &quot;u&quot;, &quot; &quot;, &quot;t&quot;, &quot;o&quot;, &quot;o&quot;]</span><br> <br><span class="hljs-keyword">var</span> b = str.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>,<span class="hljs-number">2</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b);<br><span class="hljs-comment">//以空格切割返回前两个数组元素</span><br><span class="hljs-comment">//返回[&quot;I&quot;, &quot;lover&quot;]</span><br></code></pre></td></tr></table></figure><p><strong><em>注释：</em></strong> 如果把空字符串 (“”) 用作 separator，那么 stringObject 中的每个字符之间都会被分割。</p><p><strong><em>注释：</em></strong> String.<a href="https://so.csdn.net/so/search?q=split&amp;spm=1001.2101.3001.7020">split</a>() 执行的操作与 Array.join 执行的操作效果是相反的。</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>方法用于把数组中的所有元素放入一个字符串。<strong><em>(字符串数组———&gt; 字符串)</em></strong></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">array.<span class="hljs-title function_">join</span>(separator)<br></code></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td>separator</td><td>可选。指定要使用的分隔符。如果省略该参数或者传入undefined，则使用逗号作为分隔符。</td></tr></tbody></table></div><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<br><span class="hljs-keyword">var</span> a = arr.<span class="hljs-title function_">join</span>()<span class="hljs-comment">//分割符（如果未填写，则默认为逗号 “，”）</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a);<span class="hljs-comment">//a,b,c,d,e</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">typeof</span> a);<span class="hljs-comment">//string</span><br><br><span class="hljs-keyword">let</span> arr = [<span class="hljs-string">&#x27;a&#x27;</span>, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;c&#x27;</span>, <span class="hljs-string">&#x27;d&#x27;</span>, <span class="hljs-string">&#x27;e&#x27;</span>];<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>));<span class="hljs-comment">//abcde</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;-&quot;</span>));<span class="hljs-comment">//a-b-c-d-e</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(arr.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;|&quot;</span>));<span class="hljs-comment">//a|b|c|d|e</span><br><br></code></pre></td></tr></table></figure><p><strong><em>注释：</em></strong>array.join(“”)与array.join()并不是一回事（前者无分隔符，后者逗号作为分隔符）</p><p><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212010534830.vnd.microsoft.icon" alt="image-20221201024723341"><img src="https://fastly.jsdelivr.net/gh/chongqing0111/picgo/images/202212010534830.vnd.microsoft.icon" alt="image-20221201024723341"></p><div class="tag link"><a class="link-card" title="糖果屋教程贴" href="https://akilar.top/posts/615e2dec/"><div class="left"><img src="/.top//siteicon/favicon.ico"></div><div class="right"><p class="text">糖果屋教程贴</p><p class="url">https://akilar.top/posts/615e2dec/</p></div></a></div>]]></content>
      
      
      <categories>
          
          <category> other </category>
          
      </categories>
      
      
        <tags>
            
            <tag> js </tag>
            
            <tag> test </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
